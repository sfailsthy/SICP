(define (update-data! insts machine)
  (let ((inst-category (classify insts)))
    ((machine 'update-data) inst-category
                            (find-label-regs inst-category)
                            (find-stacked-regs inst-category)
                            (find-val-sources inst-category))))


; classify the insts
(define (classify insts)
  (let ((inst-category '()))
    (for-each (lambda (instruction)
                (let* ((inst (instruction-text instruction))
                       (cate (assoc (car inst) inst-category)))
                  (if cate
                      (let ((records (cdr cate)))
                        (if (not (memq inst records))
                            (set-cdr! cate (cons inst (cdr cate)))))
                      (set! inst-category
                            (cons (list (car inst) inst)
                                  inst-category)))))
              insts)
    inst-category))

; find registers that store entries
(define (find-label-regs inst-category)
  (let ((label-registers '())
        (goto-insts (assoc 'goto inst-category)))
    (for-each (lambda (inst)
                (let ((reg (cadr (cadr inst))))
                  (if (not (memq reg label-registers))
                      (set! label-registers (cons reg label-registers)))))
              (filter (lambda (inst)
                        (register-exp? (cadr inst)))
                      (cdr goto-insts)))
    label-registers))

; find stacked registers
(define (find-stacked-regs inst-category)
  (let ((stacked-regs '())
        (stack-insts (append
                      (cdr (assoc 'save inst-category))
                      (cdr (assoc 'restore inst-category)))))
    (for-each (lambda (inst)
                (let ((reg-name (cadr inst)))
                  (if (not (memq reg-name stacked-regs))
                      (set! stacked-regs
                            (cons reg-name stacked-regs)))))
              stack-insts)
    stacked-regs))

; find sources of registers' values
(define (find-val-sources inst-category)
  (let ((val-sources '())
        (assign-insts (assoc 'assign inst-category)))
    (for-each (lambda (inst)
                (let ((reg-name (cadr inst))
                      (source (cddr inst)))
                  (let ((val-seq (assoc reg-name val-sources)))
                    (if val-seq
                        (if (not (memq (cdr val-seq) source))
                            (set-cdr! val-seq
                                      (cons source (cdr val-seq))))
                        (set! val-sources
                              (cons (list reg-name source)
                                    val-sources))))))
              (cdr assign-insts))
    val-sources))

; for presentation of collected data
(define (display-newline str)
  (display str)
  (newline))
(define (show-data cate lregs sregs sources)
  (display-newline "Instruction category:")
  (for-each (lambda (record)
              (display "  ")
              (display (car record))
              (display-newline ":")
              (for-each (lambda (inst)
                          (display "    ")
                          (display-newline inst))
                        (cdr record)))
            cate)
  (newline)
  (display-newline "Entry register:")
  (display "  ")
  (display-newline lregs)
  (newline)
  (display-newline "Stacked registers:")
  (display "  ")
  (display-newline sregs)
  (newline)
  (display-newline "Register value source:")
  (for-each (lambda (record)
              (display "  ")
              (display (car record))
              (display-newline ": ")
              (for-each (lambda (source)
                          (display "    ")
                          (display-newline source))
                        (cdr record)))
            sources))