(load "distinct.scm")

(define (flatmap proc li)
  (if (null? li)
      '()
      (let ((first (proc (car li)))
            (rest (flatmap proc (cdr li))))
        (if (pair? first)
            (append first rest)
            (cons first rest)))))

(define (permutations lists)
  (if (null? lists)
      '(())
      (flatmap (lambda (x)
                 (map (lambda (y)
                        (cons x y))
                      (permutations (cdr lists))))
               (car lists))))

(define (restrictions li)
  (apply (lambda (baker cooper fletcher miller smith)
           (and (> miller cooper)
                (not (= (abs (- smith fletcher)) 1))
                (not (= (abs (- fletcher cooper)) 1))
                (distinct? (list baker cooper fletcher miller smith))))
         li))

(define (multiple-dwelling)
  (let ((baker (list 1 2 3 4))
        (cooper (list 2 3 4 5))
        (fletcher (list 2 3 4))
        (miller (list 3 4 5))
        (smith (list 1 2 3 4 5)))
    (filter restrictions (permutations (list baker cooper fletcher miller smith)))))